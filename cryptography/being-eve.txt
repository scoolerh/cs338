Hannah Scooler

Using the following code, I was able to solve for a 
and b, which consequently allowed me to solve for K. This 
resulted in the conclusion that K = 8. 

    #the values that Eve intercepted 
    g = 7
    p = 61
    A = 30
    B = 17

    #find the random a that Alice generated by testing a bunch 
    #of possible values until it solves 
    for i in range(100):
        if (((g^i)%p) == A):
            print(str(i) + " is a!")
            a = i
            break

    #solve for K !!! 
    K = (B^a)%p 
    print(str(K) + " is K!")

Although I was able to solve for K using only a few lines of
code and minimal time spent, if the integers had been larger
then I would have had to test a lot more integers to find a. This would
have taken a much larger time, which might not have been feasible. 
For example, if a were a number like 148591402943 instead of 25,
I would have had to test hundreds of billions of other numbers
until I found a, needing a much larger for loop. This would probably 
take an absurd amount of time and computing power. 

From looking it up, I know that 170171 (n) can be factored into the 
prime numbers 379 and 449, so I knew those must be p and q respectively. 
From this, using the following code, I was able to find that d = 119537. 

    e = 17
    p = 379
    q = 449
    for d in range(100000000):
        if ((e*d)%((p-1)*(q-1)) == 1):
            print(str(d) + " is d!")
            break

Then, I could use the values of d and n to decode each M in 
the message using the following code. I first used the 
M = M^d %n formula on each integer in the array, and saw that 
this returned a new series of large integers. This confused me at 
firtst, but then I was able to realize that it was encoded in
2 byte decimal chunks, so each integer corresponded with two bytes 
that could be translated into ASCII. Thus, I added code to convert 
the integers from decimal to binary, including padding the binary to 
make sure that the whole 16 bits were included in the returned binary. 

    d = 119537
    n = 170171
    decoded = ""
    for cipher in encrypted: 
        binary = str(bin((cipher**d)%n))
        binary = binary[2:10]
        while(len(binary) < 18):
            binary = "0" + binary
        binary1 = binary[2:10]
        binary2 = binary[10:]
        decoded += binary1 + " " + binary2 + " "
    print(decoded)

By putting the binary that this returned into a Binary to ASCII 
translator, I was able to decrypt that the message says: 

    Hi Bob. I'm walking from now on. Your pal, Alice. 
    https://foundation.mozilla.org/en/privacynotincluded/
    articles/its-official-cars-are-the-worst-product-category
    -we-have-ever-reviewed-for-privacy/

Again, if n and e had been larger integers, then it would take much
more computing power to factor n to find the prime numbers p and q.
As it was, I could just google it and find the results almost automatically.
However, if n had been larger then this would not have been an option
and could have prevented the attacker from being able to get past that
step. Also, my for loop would have needed to go through a range of a 
much higher magnitude. There would have been many more possibilities 
for d, and the time needed to brute force solve for d might not have 
been feasible. 

Even if Bob had used larger integers, this encoding would still be 
insecure because it relies only on each individual chunk, rather than 
having the encoding rely on the content of the whole message. Since 
the encoded chunks are all independent, there is still the chance that 
an attacker could use decode the message using an attack like letter 
frequency, even without having the private key. A better method would 
be to use an encoding that relied on the previous chunk to encode the 
current chunk, such as CBC. 
